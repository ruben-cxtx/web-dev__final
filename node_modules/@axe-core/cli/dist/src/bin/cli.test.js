"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("mocha");
const chai_1 = require("chai");
const tempy_1 = __importDefault(require("tempy"));
const http_1 = __importDefault(require("http"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const package_json_1 = require("../../package.json");
const testutils_1 = __importDefault(require("../testutils/"));
const SIMPLE_HTML_FILE = path_1.default.join(__dirname, '..', 'testutils', 'simple.html');
const SIMPLE_CLEAN_HTML_FILE = path_1.default.join(__dirname, '..', 'testutils', 'simple-clean.html');
const SIMPLE_HTML_SOURCE = fs_1.default.readFileSync(SIMPLE_HTML_FILE, 'utf8');
const PATH_TO_AXE_250 = path_1.default.resolve(__dirname, '..', 'testutils', 'axe-core@2.5.0.js');
describe('cli', () => {
    it('--help', () => __awaiter(void 0, void 0, void 0, function* () {
        const result = yield (0, testutils_1.default)('--help');
        chai_1.assert.equal(result.exitCode, 0);
        chai_1.assert.include(result.stdout, 'Options:');
    }));
    it('--version', () => __awaiter(void 0, void 0, void 0, function* () {
        const result = yield (0, testutils_1.default)('--version');
        chai_1.assert.equal(result.exitCode, 0);
        chai_1.assert.deepEqual(result.stdout, package_json_1.version);
    }));
    describe('given a file:// url', () => {
        it('should run an analysis', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`);
            chai_1.assert.equal(result.exitCode, 0);
            chai_1.assert.include(result.stdout, 'Violation of "marquee" with 1 occurrences!');
        }));
    });
    describe('given a http:// url', () => {
        let port;
        let server;
        before(done => {
            server = http_1.default.createServer((req, res) => {
                res.setHeader('Content-Type', 'text/html');
                res.write(SIMPLE_HTML_SOURCE);
                res.end();
            });
            server.listen(0, () => {
                port = server.address().port;
                done();
            });
        });
        after(done => server.close(done));
        it('should run an analysis', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`http://127.0.0.1:${port}/`);
            chai_1.assert.equal(result.exitCode, 0);
            chai_1.assert.include(result.stdout, 'Violation of "marquee" with 1 occurrences!');
        }));
    });
    describe('--axe-source', () => {
        it('should use the provided version of axe-core', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--axe-source', PATH_TO_AXE_250);
            chai_1.assert.equal(result.exitCode, 0);
            chai_1.assert.include(result.stdout, 'Violation of "marquee" with 1 occurrences!');
            chai_1.assert.include(result.stdout, 'Running axe-core 2.5.0');
        }));
        it('error when given invalid axe source path', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--axe-source', 'foobar');
            chai_1.assert.equal(result.exitCode, 2);
            chai_1.assert.include(result.stderr, 'Unable to find the axe-core source file');
        }));
    });
    // cannot run in ci we _should_ have the ability to add arguments to firefox not just chrome to allow users to run this headless
    describe.skip('--browser', () => {
        it('should change the browser', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--browser', 'firefox', '--verbose');
            chai_1.assert.equal(result.exitCode, 0);
            chai_1.assert.include(result.stdout, 'Firefox');
        }));
    });
    describe('--rules', () => {
        it('should only run the rules with the provided IDs', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--rules', 'region');
            chai_1.assert.equal(result.exitCode, 0);
            chai_1.assert.include(result.stdout, 'Violation of "region" with');
        }));
    });
    describe('--tags', () => {
        it('should only run rules with the provided tags', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--tags', 'cat.parsing,wcag222');
            chai_1.assert.equal(result.exitCode, 0);
            // Region is tagged with "cat.keyboard", "best-practice"
            chai_1.assert.notInclude(result.stdout, 'Violation of "region" with');
        }));
    });
    describe('--exit', () => {
        it('should exit non-zero if violations are found', () => __awaiter(void 0, void 0, void 0, function* () {
            try {
                yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--exit');
            }
            catch (error) {
                chai_1.assert.equal(error.exitCode, 1);
                chai_1.assert.include(error.stdout, 'Violation of "marquee" with 1 occurrences!');
            }
        }));
        it('should exit zero if violations are found', () => __awaiter(void 0, void 0, void 0, function* () {
            try {
                yield (0, testutils_1.default)(`file://${SIMPLE_CLEAN_HTML_FILE}`, '--exit');
            }
            catch (error) {
                chai_1.assert.equal(error.exitCode, 0);
                chai_1.assert.include(error.stdout, 'Violation of "marquee" with 1 occurrences!');
            }
        }));
    });
    describe('--dir', () => {
        let reportDir;
        beforeEach(() => {
            reportDir = tempy_1.default.directory();
        });
        it('should save a JSON report to the provided directory', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--dir', reportDir);
            chai_1.assert.equal(result.exitCode, 0);
            const files = fs_1.default.readdirSync(reportDir);
            const report = files.find(f => f.endsWith('.json'));
            (0, chai_1.assert)(report, 'Did not create JSON report');
        }));
    });
    describe('--include', () => {
        it('should set a list of elements to include', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--include', 'marquee');
            chai_1.assert.notInclude(result.stdout, 'Violation of "region"');
            chai_1.assert.include(result.stdout, 'Violation of "marquee" with 1 occurrences!');
        }));
        it('should throw error if CSS selector is not found', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--include', '#hazaar', '--show-errors');
            chai_1.assert.include(result.stderr, 'javascript error: No elements found for include in page Context');
            chai_1.assert.equal(result.exitCode, 1);
        }));
        it('should throw error if invalid selector is provided', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--include', '#123', '--show-errors');
            chai_1.assert.include(result.stderr, 'is not a valid selector');
            chai_1.assert.equal(result.exitCode, 1);
        }));
    });
    describe('--exclude', () => {
        it('should set a list of elements to exclude', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--exclude', 'marquee');
            chai_1.assert.notInclude(result.stdout, 'Violation of "marquee" with 1 occurrences!');
        }));
        it('should throw error if invalid selector is provided', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--exclude', '#123', '--show-errors');
            chai_1.assert.include(result.stderr, 'is not a valid selector');
            chai_1.assert.equal(result.exitCode, 1);
        }));
    });
    describe('--disable', () => {
        it('should not run rules with the provided IDs', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--disable', 'region');
            chai_1.assert.notInclude(result.stdout, 'Violation of "region" with');
        }));
    });
    describe('--stdout', () => {
        it('should only emit JSON to stdout', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--stdout');
            chai_1.assert.equal(result.exitCode, 0);
            chai_1.assert.doesNotThrow(() => JSON.parse(result.stdout), 'Emitted invalid JSON');
        }));
    });
    describe('--timer', () => {
        it('should log the time it takes to run', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--timer');
            chai_1.assert.equal(result.exitCode, 0);
            chai_1.assert.isEmpty(result.stderr);
            chai_1.assert.include(result.stdout, 'axe-core execution time');
            chai_1.assert.include(result.stdout, 'Total test time');
        }));
    });
    describe('--no-reporter', () => {
        it('should log the time it takes to run', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--no-reporter');
            chai_1.assert.equal(result.exitCode, 0);
            chai_1.assert.notInclude(result.stdout, 'Violation of "marquee" with 1 occurrences!');
        }));
    });
    describe('--show-errors', () => {
        it('should log the time it takes to run defaults to show errors', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--include', '#hazaar');
            chai_1.assert.equal(result.exitCode, 1);
            chai_1.assert.include(result.stderr, 'Error: JavascriptError: javascript error:');
        }));
        it('do not show errors when passed false', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--include', '#hazaar', '--show-errors', 'false');
            chai_1.assert.equal(result.exitCode, 1);
            chai_1.assert.include(result.stderr, 'An error occurred while testing this page.');
        }));
    });
    describe('--save', () => {
        let reportDir;
        beforeEach(() => {
            reportDir = tempy_1.default.directory();
        });
        it('should save the output as a JSON file', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--save', 'test-name.json', '--dir', reportDir);
            const [report] = fs_1.default.readdirSync(reportDir);
            chai_1.assert.equal(result.exitCode, 0);
            chai_1.assert.equal(report, 'test-name.json');
        }));
    });
    describe('--load-delay', () => {
        it('should set how much time axe will wait after a page loads before running the audit', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--load-delay', '1000');
            chai_1.assert.equal(result.exitCode, 0);
            chai_1.assert.include(result.stdout, 'Waiting for 1000 milliseconds after page load');
        }));
    });
    describe('--verbose', () => {
        it('should output metadata such as test tool name, version and environment', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--verbose');
            chai_1.assert.equal(result.exitCode, 0);
            chai_1.assert.include(result.stdout, 'Test Runner');
            chai_1.assert.include(result.stdout, 'Test Engine');
            chai_1.assert.include(result.stdout, 'Test Environment');
        }));
    });
    describe('--timeout', () => {
        // Timeout the page immediately. Ideally we'd block the page for awhile, then timeout based on that. This seemed easier for now tho.
        it('should set the page load timeout', () => __awaiter(void 0, void 0, void 0, function* () {
            try {
                yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--timeout', '0');
            }
            catch (error) {
                chai_1.assert.notEqual(error.exitCode, 0);
                chai_1.assert.include(error.stderr, 'An error occurred while testing this page.');
            }
        }));
    });
    // disabled during conversion to npm workspaces as the node_module install directory changed
    // @see https://github.com/dequelabs/axe-core-npm/issues/822
    describe.skip('--chromedriver-path', () => {
        it('should throw error if path does not exist', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--chromedriver-path="someinvalidpath"', '--show-errors');
            chai_1.assert.include(result.stderr, 'The specified executable path does not exist');
        }));
    });
    describe('--chrome-path', () => {
        it('should throw error if path does not exist', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, testutils_1.default)(`file://${SIMPLE_HTML_FILE}`, '--chrome-path="someinvalidpath"', '--show-errors');
            chai_1.assert.include(result.stderr, 'no chrome binary at');
        }));
    });
});
//# sourceMappingURL=cli.test.js.map